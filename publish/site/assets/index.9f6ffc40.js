var t=Object.defineProperty,e=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable,i=(e,o,s)=>o in e?t(e,o,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[o]=s,n=(t,n)=>{for(var r in n||(n={}))o.call(n,r)&&i(t,r,n[r]);if(e)for(var r of e(n))s.call(n,r)&&i(t,r,n[r]);return t},r=(t,e,o)=>(i(t,"symbol"!=typeof e?e+"":e,o),o);const a=(t,e,o)=>t+o*(e-t),l=(t,e,o)=>[a(t[0],e[0],o),a(t[1],e[1],o)];const c=(t,e,o)=>{const s=document.createElement(t);for(let i in e){const t=e[i];"string"==typeof t?s.setAttribute(i,t):Reflect.set(s,i,t)}return s.append(...o),s},h=(t,e={},o)=>{const s=c("output",{for:t},[]),i=c("input",n({id:t,onclick:r,oninput:r,onchange:r},e),[]);function r(t){o(t,i),s.value=i.value,s.textContent=i.value}function a(){r({currentTarget:i})}const l=c("div",{class:"Input"},[c("label",{for:t},[t]),i,s]);return l.update=a,a(),l},d=document.createElement("canvas");document.body.append(d),d.width=d.clientWidth,d.height=d.clientHeight;const p=d.getContext("2d"),u=new class{constructor(t,e=t.canvas){r(this,"ctx"),r(this,"target"),r(this,"activeStrokes",new Map),r(this,"pointerData",new Map),r(this,"strokeHistory",[]),r(this,"undoHistory",[]),r(this,"style",{backgroundColor:"#fff"}),r(this,"strokeStyle",{size:5,color:"#2685CB",smoothing:.1}),this.ctx=t,this.target=e,t.lineJoin="round",t.lineCap="round";const o={capture:!0,passive:!0};["pointerdown","pointermove","pointerup","pointerout","pointercancel","pointerleave"].forEach((t=>e.addEventListener(t,this,o)))}set backgroundColor(t){this.style.backgroundColor=t,this.render()}set strokeSize(t){this.strokeStyle.size=t,this.ctx.lineWidth=t}set strokeColor(t){this.strokeStyle.color=t,this.setCanvasStyle(this.strokeStyle)}set strokeSmoothing(t){this.strokeStyle.smoothing=Math.max(1-t,.05)}setStrokeStyle(t){this.setCanvasStyle(this.strokeStyle=t)}setCanvasStyle(t){this.ctx.lineWidth=t.size,this.ctx.strokeStyle="currentBackground"===t.color?this.style.backgroundColor:t.color}drawPoint({point:t,stroke:e,pointerData:o}){this.ctx.beginPath(),this.ctx.quadraticCurveTo(o.emulated[0],o.emulated[1],t[0],t[1]),this.ctx.stroke(),o.emulated=t}handlePoint({pointerData:t,stroke:e,point:o}){this.drawPoint({point:o,stroke:e,pointerData:t}),e.points.push(o),this.undoHistory.length>0&&(this.undoHistory=[])}moveTowardsPointer(t,e,o=e.style.smoothing){t.smoothingFn=setInterval((()=>{var s,i;if((s=t.emulated,i=t.lastPoint,Math.sqrt((i[0]-s[0])**2+(i[1]-s[1])**2))<1)return;const n=l(t.emulated,t.lastPoint,o);this.handlePoint({pointerData:t,stroke:e,point:n}),t.emulated=n}),5)}handleEvent(t){const e=t.pointerId,o=[t.offsetX,t.offsetY],s=this.activeStrokes.get(e),i=this.pointerData.get(e);switch(t.type){case"pointerdown":{const t={style:n({},this.strokeStyle),points:[o]};this.activeStrokes.set(e,t);const s={emulated:o,lastPoint:o};this.pointerData.set(e,s),this.target.setPointerCapture(e),this.handlePoint({pointerData:s,stroke:t,point:o});break}case"pointermove":if(s){clearTimeout(i.smoothingFn),t.getCoalescedEvents().forEach((t=>{const e=l(i.emulated,[t.offsetX,t.offsetY],s.style.smoothing);this.handlePoint({stroke:s,point:e,pointerData:i})}));const n=l(i.emulated,o,s.style.smoothing);this.handlePoint({stroke:s,point:n,pointerData:this.pointerData.get(e)}),i.lastPoint=o,i.smoothingFn=setTimeout((()=>this.moveTowardsPointer(i,s)),10)}break;case"pointerup":case"pointerout":case"pointerleave":case"pointercancel":s&&(this.handlePoint({stroke:s,point:o,pointerData:i}),clearTimeout(i.smoothingFn),this.strokeHistory.push(s),this.activeStrokes.delete(e),this.target.releasePointerCapture(e))}}render(){this.ctx.fillStyle=this.style.backgroundColor,this.ctx.fillRect(0,0,this.ctx.canvas.width,this.ctx.canvas.height),this.strokeHistory.forEach((t=>{this.setCanvasStyle(t.style);const e={emulated:t.points[0],lastPoint:t.points[0]};t.points.forEach((o=>{this.drawPoint({point:o,stroke:t,pointerData:e})}))})),this.setCanvasStyle(this.strokeStyle)}undoStroke(){const t=this.strokeHistory.pop();t&&(this.undoHistory.push(t),this.render())}redoStroke(){const t=this.undoHistory.pop();t&&(this.strokeHistory.push(t),this.render())}}(p),k=[{},{color:"currentBackground"}];let y=k[0];u.setStrokeStyle(y);const m=[h("background color",{type:"color",value:"#fafafa"},((t,e)=>{u.backgroundColor=e.value})),h("stroke color",{type:"color",value:"#101010"},((t,e)=>{u.strokeColor=e.value})),h("stroke size",{type:"range",min:0,max:200,step:1,value:5},((t,e)=>{u.strokeSize=e.valueAsNumber})),h("stabilization",{type:"range",min:0,max:1,step:.01,value:.75},((t,e)=>{u.strokeSmoothing=e.valueAsNumber})),h("erase",{type:"checkbox",checked:!1},((t,e)=>{e.value=e.checked,y=e.checked?k[1]=n(n({},k[0]),k[1]):k[0],u.setStrokeStyle(y)}))];document.body.prepend(c("form",{},m)),window.addEventListener("keydown",(t=>{t.ctrlKey&&"z"===t.key&&u.undoStroke(),t.ctrlKey&&"Z"===t.key&&u.redoStroke()})),window.addEventListener("resize",(()=>{requestAnimationFrame((()=>{d.width=d.clientWidth,d.height=d.clientHeight,u.ctx.lineJoin="round",u.ctx.lineCap="round",u.render()}))}));
